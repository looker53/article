[toc]



## 目录

（该文章要求我们多读几个框架源码，像 webpy, bottle, flask）

- web框架的功能设计（一个微框架需要包含哪些核心功能）
    - 核心是处理请求、返回响应
    - 方便自定义路由
    - 服务和应用分离（WSGI）
    - 常见的中间件支持
- 如何编程处理网络请求（socket）
- HTTP 消息规范
- 如何接收 HTTP 请求
    - HTTP 请求规范
    - 获取 URL 和 客户端地址（如何 ban ip）
    - 获取请求方法
    - 获取请求头
    - 获取请求体
- 如何返回 HTTP 响应
    - HTTP 响应规范
    - 普通文本响应
    - 错误处理
    - HTML 文件响应（TODO:模板支持）
    - JSON 数据响应
    - 文件响应
- 服务和应用拆分
    - WSGI 协议
- 多线程支持
- 路由
- 中间件
    - 登录
    - 数据库


##  web框架的功能设计

我是一名python开发者，平时的主要工作是编写自动化程序，偶尔会把一些自动化程序集成到网页当中，提供用可视化的界面，让自动化程序变得更加容易使用。在实际的工作过程当中，我接触了非常多优秀的 Web开发框架，比如非常主流的 Django 框架，它提供的功能非常的丰富；还有很多人入门学习的 Flask框架，他的设计与众不同，而且提供了非常丰富的插件系统；还有近年来非常流行的 FastAPI 框架，它提供了传统框架没有的序列化功能、依赖注入功能及后台任务功能。


这些框架的核心用法实际上大同小异，只要掌握了其中的一个，去学习另外的框架也会很简单。 但是在现实生活当中总是会有很多人争论：到底哪一个框架更先进,到底那个框架容易使用？ 每次听到这样的争吵，我总是会思考一个问题：一个web开发框架究竟应该具备哪些核心的功能，而哪些功能可以通过比较方便的形式进行扩展？

当第一次接入接触web开发的时候，哪些知识应该重点去学习，而哪些可以慢慢摸索呢？在出现一些比较隐秘的问题需要解决时，应该采取什么方式去进行调试呢？这些问题都可以通过研究框架结构、深入学习源码而解决，但是随着这些现成框架的发展，他们的底层api已经隐藏的非常深，要弄清它们的原理并不容易。

这让我萌生出自己开发一个玩具框架的设想，通过设计这一个玩具框架，我会明白一个Web开发框架应该具备什么样的核心功能，而这些核心功能究竟是通过一种怎样的机制完成的。 之后再采用这个设计蓝图和实现方式去理解目前主流框架的用法，应该会变得更加简单。


这个玩具框架的初步设想，是实现一个web框架应该具备的核心功能，之后再去考虑扩展功能，比如说加入数据库的支持，加入序列化和反序列化，加入后台任务的执行，加入依赖注入的功能，加入插件系统的研发。

那么一个web框架，首先应该具备一些什么样的核心功能呢？

在不考虑易用性的前提下，一个web框架必须具备的能力是: 接收用户发送过来的请求，经过开发者的处理之后，给用户返回开发者预先设置的响应结果。现阶段大多数web应用基于 http 协议，当 web 框架接收用户传过来的数据流之后，需先验证是否符合 http 规范。如果符合，再从中解析出请求首行、请求头以及请求体等内容。中间是应用处理环节，开发者拿到web框架解析完的请求数据之后，编写对应的处理代码，得到最终需要返回给用户的数据。最后，框架拿到开发者的返回数据，再转化成符合http规范的数据，用户便能从客户端得到响应结果。这个流程可以通过下图表示：

用户 --> 框架（验证，开发者代码，拼接 http 响应） --> 用户
（图）

当框架完成这些核心功能之后，给开发者留下方便调用的接口，让开发者业务代码和框架产生关联。那么开发者需要编写的代码有哪些呢？首先开发者需要自己定义 URL 和需要执行的代码之间的映射关系（通常定义成函数或者方法）。框架接收所有用户发过来的请求，从中得到url路径，如果该路径已经被开发者预先设置，则调用映射的代码；如果 url 没有被开发者预先配置，框架直接返回 404 状态码。其次，开发者可以更预先设置访问某个 URL 的请求方法，如果进入的该 URL 的请求方法满足预先条件，才执行映射的代码，否则 web 框架会直接抛出 405 状态码。

用户  -->  URL不匹配 --> 404
            URL 匹配  --> 开发者代码 --> response

例如，开发者预先设置进入`/login`路径的请求方法只能是 POST 请求。当一个访问该路径的请求被框架解析后，读取实际请求方法为 GET，则直接被框架定义为非法请求，返回 405 状态码，完全不会进入开发者业务。只有当实际的请求方法和开发者设置的请求方法匹配时，才会进入开发者定义的代码逻辑。

用户 -->  URL 匹配 --> 请求方法不匹配 --> 405
                       请求方法匹配  --> 开发者代码 --> Respone

只要实现了对请求方法的验证，可以基于同样的原理，由开发者预先设置其他请求数据的规则，只有符合规则，才调用开发者业务。 比如，请求头必须带有指定参数，客户端 IP 不能在黑名单，指定 IP 在规定时间内只能访问限制范围次数，甚至请求体的每个字段必须满足什么条件等等。 这些验证过程可以通过框架实现，也可以写成扩展的形式。 框架本身只要能够获取请求的url路径、请求方法、请求头、请求体、远程ip等内容，就可以用任意方式实现这些功能，FastAPI 就是在框架层面支持了反序列化以及请求校验的功能，而 Flask 对不同的请求部分验证采用了不同实现方式，有的通过路由配置，有的通过 request 读取，有的通过插件接入。


用户 --> URL适配 --> Response
        请求方法
        请求头
        IP


经过框架解析后，请求数据保存到 Request 类当中，一旦请求数据通过URL、请求方法以及请求头等验证过程，框架调用开发者自定义的处理逻辑，这个处理逻辑通常是一个函数或者是方法，我们把它成为视图函数（View Function）。 视图函数以用户的请信息 Request 为参数，以响应信息（Response）作为函数的返回值。之后，response 会被框架进一步处理，转化成符合 HTTP 规范的响应流，返回给客户端。


综上，玩具框架会实现的核心功能有：一、处理用户的请求，从中解析出请求路径、请求方法、请求头、请求体以及远程客户端地址等信息，封装到 Request 对象中；二、提供简单易用的开发者调用接口，通过这些接口，开发者可以设置url和自定义函数的绑定关系，同时可以对请求方法等进行简单的配置。三、框架将开发者函数返回的响应对象序列化成标准的 HTTP 响应流，返回给客户端，响应体支持文本、json以及html格式,暂且不考虑模板渲染技术。


接下来我们考虑非核心但是有必要实现的功能。

第一个是服务和应用的分离。服务主要做的事情是监听端口和数据发送，它只涉及到二进制流数据的处理，做的事情更接近底层，通常和业务逻辑不会发生任何关系。而应用程序主要负责具体业务的对接。比如说将请求封装成request对象、进行数据验证，然后提供给视图函数进行进一步处理。

服务的工作更简单，更标准，相当于一个看门人。而应用做的事情更复杂，更需要定制化。当服务和应用分离之后，可以对服务进行多线程或多进程的支持，甚至可以使用一些性能更高的编程语言来实现。访问服务的数据是非常庞大的，通常需要比较好的性能支持。

一个服务可以挂载多个应用程序。而每一个应用程序所实现的功能可以截然不同，甚至每一个应用所使用的具体技术也可以截然不同。服务可以基于不同的判断标准对请求进行分派，指定对应的应用进行请求对接，判断标准可以用户的访问路径、用户的远程ip地址。 我们还可以只实现应用，然后选用已经成熟的服务监听端口。比如说uwsgi,gunicorn或者 uvicorn 等等。

在 Python的 web开发技术中，目前有一个服务和应用分离的标准叫 wsgi，主流的 Python 开发框架都是基它来实现的。在玩具框架的实现过程中，我将先通过普通的方式将服务和应用分离，然后再逐步探讨 wsgi 的实现原理，过渡到符合 wsgi 标准的框架。


第二个是中间件支持，其中最重要的是数据库支持以及用户鉴权。首先来看数据库支持，比较简单的方式是将数据库操作直接写入开发者自定义的视图函数当中，框架完全不需要任何的数据库处理。但是这种操作方式把工作都交给了开发者，开发速度会降低，而且容易出问题。 另一个弊端是数据库的初始化、数据迁移需要维护独立的脚本文件，非常不方便。

框架最好能支持 ORM 的使用，这种方式让开发者操作数据库变得更加的方便易懂，能有效降低安全漏洞，如果一个框架能支持数据库引擎接入以及 ORM 的使用，对开发者绝对是善事一桩。


其次是用户鉴权，它往往需要框架在请求验证阶段，对用户进行过滤，符合条件才能进入视图函数，否则将直接拦截请求，返回401 状态码。通过实现这样的功能，我们也可以更加清晰的去理解目前主流使用的开发框架当中，是如何管理用户登录态的。

一个开发者，如果想迅速上手一个 web 框架，应该立即搞明白的用法有：
- 如何获取请求头、请求体、请求方法已经远程客户端信息
- 如何返回响应体、响应头、响应状态码
- 如何配置 web 服务用在正式环境
- 如何编写数据库操作代码
- 如何进行用户鉴权，管理用户状态


通过玩具框架实现完这些功能之后，我们会进一步去探讨：目前主流使用的web框架，是如何去实现这些功能的， 我们以 Django、Flask、Bottle 以及 FastAPI 为例子，尽量全面、深入的分析这些核心功能的实现过程，以及这些优秀框架的实现方式和我们自己的实现方式有什么优势。



## 如何编程处理网络请求（socket）

服务端的网络处理过程和接听电话非常的类似，它的主要操作流程有：绑定地址、监听、同意接收、获取信息以及响应。

先看一下接听电话的过程。首先你需要有一个电话号码，当别人找你的时候，就可以拨打这个电话号码，这就是绑定地址。 你从其他的途径听说有一个人将会赠予你500万，他正式通知你的时候，会拨打你的电话。于是你会每天焦急的等待是否有陌生人拨打你这一个电话号码，这个过程就是监听。 接下来有陌生电话进来的时候，你会按下接听键来表示同意别人和你通话。 一旦经过你的同意，你就可以听到远端发出来的声音，这是获取信息的过程。如果这个声音不是你等的那个人，而是推销广告，你会非常愤怒的挂断电话表示回应。 如果你刚好遇到了那一个人，那你会非常友善的和他去进行进一步的通话...


服务端在具体的网络处理过程当中，会使用socket技术实现这整个流程。

socket 是一套操作系统提供的网络通讯协议，在国内习惯称为套接字。 一台计算机的 IP 地址和端口号会组成套接字地址（socket address），加上远程服务器的套接字地址，以及使用的网络协议（比如TCP，UDP） ，五个要素共同组成一个套接字对（socket pairs)，之后就可以交换数据。在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。

![image-20211019170751710](https://yuztuchuang.oss-cn-beijing.aliyuncs.com/img/image-20211019170751710.png)

编程语言会对计算机上的套接字协议进行封装，从而实现编程语言的网络请求操作。因为这个封装偏底层，所以在平时的编程过程中很少直接接触到，我们接触的，主要是那些基于 socket 进行了更高层级封装的网络处理库，这些库用起来更加简单，但是基本上都是基于 socket 实现的，像 requests 库，httpx 库。理解 socket 对深入研究这些网络请求库的原理有帮助，当出现问题时，调试起来会更有底气。

来看一下在python当中如何通过socket来实现服务接收请求的过程。

```python
import socket

HOST = '127.0.0.1'
PORT = 9999
ADDRESS = (HOST, PORT)

with socket.socket(
        family=socket.AF_INET,
        type=socket.SOCK_STREAM
) as server_socket:
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(ADDRESS)
    server_socket.listen(8)
    print(f'Start {HOST}:{PORT}')

    client_sock, address = server_socket.accept()
    print(f"connect from {address}")
```
- socket.socket() 初始化一个 socket 对象，SOCK_STREAM 表示使用 TCP 协议， 使用 SOCK_DGRAM 表示 UDP 协议；
- setsockopt 行设置选项，如果套接字地址被占用，可以重新使用；
- bind 绑定域名和端口，之后就可以监听连接这个套接字地址的请求；
- listen 监听这个套接字地址；
- accept 表示接受其他链接并返回一个客户端 socket 和地址

现在你可以在浏览器或者其他的网络访问工具上访问 127.0.0.1:9999 这个套接字地址，当有一个请求链接后，则会打印客户端地址。但是这个服务只能接受一个连接，然后就会自动退出。如果需要接受多个连接，需要写一个 while 循环，一旦连接建立，则可以通过 sendall 往客户端发送数据，也可以通过 recv 接收指定长度的数据。
```python
import socket

HOST = '127.0.0.1'
PORT = 9999
ADDRESS = (HOST, PORT)

with socket.socket(
        family=socket.AF_INET,
        type=socket.SOCK_STREAM
) as server_socket:
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(ADDRESS)
    server_socket.listen(8)
    print(f'Start {HOST}:{PORT}')
    while True:
        client, address = server_socket.accept()
        print(f"connect from {address}")
        data = client.recv(1024)
        print(data)
        client.sendall(b"hello")
```

现在你可以打开浏览器频繁访问服务，在服务端的控制台中会显示多次请求，。但是在浏览器中无法查看到 hello 这个响应结果，原因是在打开浏览器访问服务端时，服务端接收的虽然是基于 TCP 的 HTTP 请求，但是响应并没有基于 HTTP 进行格式的转化，还是普通的 TCP 数据，浏览器并不能直接获取。

![image-20211019165456110](https://yuztuchuang.oss-cn-beijing.aliyuncs.com/img/image-20211019165456110.png)



要查看响应结果，最快捷的方式是使用能处理普通 TCP 数据的客户端，使用 telnet 工具，就能看到服务端返回的数据 hello：

```
telnet 127.0.01 9999
```



第二种方式是通过 Python 编写一个客户端，访问刚刚创建好的服务：

```python
import socket

HOST = '127.0.0.1'
PORT = 9999
ADDRESS = (HOST, PORT)

with socket.socket() as sock:
    sock.connect((HOST, PORT))
    print(f"connecting server {HOST}:{PORT}")
    sock.sendall(b"hello,server")
    data = sock.recv(1024)
print(f"服务器返回结果：{data.decode()}")
```

- 客户端并不需要 bind， listen 的操作，每次创建 socket 会随机选取一个可用端口号。
- 需要访问服务端时使用 connect 建立远程连接。
- 通过 sendall 发送数据
- 也可以通过 recv 从远程服务器接受响应结果。



## HTTP 服务

现在我们要对服务进行升级，支持 HTTP 协议。当你使用了特定的协议，发送的数据就需要符合某个规则。假设你在浏览器当中往服务器发送了一个 http 请求，服务器只简单的响应 b"hello world" 就不符合 http 协议的规范，这个响应结果并不能在浏览器中直接看到，如果通过浏览器的 f12 查看，会发现没有响应结果。 



还记得我们在服务端代码中打印了浏览器发送过来的请求数据吗？

```python
with client:
    print(f"connect from {address}")
    data = client.recv(1024)
    print(data)
```



这些请求数据就符合 HTTP 规范，它分为请求首行、请求头等部分，每个部分通过 `\r\n` 隔开：

```
GET /?username=mingtian HTTP/1.1\r\n
Host: localhost:9999\r\n
Connection: keep-alive\r\n
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n
Accept-Language: zh-CN,zh;q=0.9\r\n
```

现在我们只需要把响应结果也做一下变化，改成符合 HTTP 规范的数据格式：

```
HTTP/1.1 200 OK\r\n
Content-type: text/html;charset=utf-8\r\n
Content-length: 11\r\n
\r\n
hello world
```

- 每行数据以\r\n结尾，而不是\n
- 第一行是响应首行，包好协议版本和状态码
- 第2/3 行是响应头，Content-length 一定要提供，表示响应体的长度，浏览器读完这个长度的数据就可以渲染了，如果不指定，浏览器会一直尝试加载。
- 响应头结束后，空一行再添加响应体。响应体的长度会由 Content-length 头指定。

```python
import socket

HOST = '127.0.0.1'
PORT = 9990

RESPONSE = b'''\
HTTP/1.1 200 OK
Content-type: text/html;charset=utf-8
Content-length: 11

hello world
'''.replace(b'\n', b'\r\n')

with socket.socket() as sock:
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((HOST, PORT))
    sock.listen()
    print(f"start server {HOST}:{PORT}")
    while True:
        client, address = sock.accept()
        print(f"connect from {address}")
        client.sendall(RESPONSE)
```

现在你搭建了一个非常简单的 http 服务器，可以使用火狐或者chrome浏览器访问看到响应结果

![image-20211019173913127](https://yuztuchuang.oss-cn-beijing.aliyuncs.com/img/image-20211019173913127.png)

## 扩展

### 扩展：聊天室

如果不想直接关闭客户端程序，而是进行双向多次通讯，则可以稍微修改前后端代码。

服务端代码：

服务端现在只在连接之后返回一次 response, 之后这次链接就不会有新的响应了。如果需要多次通讯，通过在 client 的上下文中加入 while 循环，如果客户端有新的数据发送过来，可以多次发送。

```
import socket

HOST = '127.0.0.1'
PORT = 9998

with socket.socket() as s:
    s.bind((HOST,PORT))
    s.listen()
    while True:
        client, address = s.accept()
        with client:
            while True:
                data = client.recv(1024)
                if not data:
                    break
                print("收到数据",data.decode())
                resp = input("回复：")
                client.sendall(resp.encode())
```

客户端代码也加入 while 循环，接收服务端返回的数据。

```
import socket

HOST = '127.0.0.1'
PORT = 9998

with socket.socket() as s:
    s.connect((HOST, PORT))
    s.sendall("正在连接主机".encode())
    while True:
        data = s.recv(1024)
        if not data:
            break
        print("收到数据",data.decode())
        content = input("输入信息：")
        s.sendall(content.encode())
```

效果：

![](https://yuztuchuang.oss-cn-beijing.aliyuncs.com/img/socket_chat.gif)

TODO: 非阻塞



### 扩展：HTTP 客户端开发

在第一节我们写了一个很简单的客户端代码连接服务器：

```
import socket

HOST = '127.0.0.1'
PORT = 9990

with socket.socket() as sock:
    sock.connect((HOST, PORT))
    print(f"connecting server {HOST}:{PORT}")
    sock.sendall(b"hello")
    data = sock.recv(1024)
print(f"服务器返回结果：{data.decode()}")
```

如果我们需要接收完整的服务器响应数据，需要修改代码：建立连接后，首先需要准备请求数据，发送请求。

```
HOST = 'httpbin.org'
PORT = 80

with socket.socket() as s:
    s.connect((HOST, PORT))
    # 发送请求
    s.sendall(b"abc")
    response = b''
    while True:
        try:
            data = s.recv(1024)
        except ConnectionResetError as e:
            break
        if not data:
            break
        response += data
print(response.decode())
```

通过上面的代码访问，服务器返回的是 400 bad request，因为我们没有按照 http 规范发送请求数据。还记不记得我们之前讲过 HTTP 协议的响应格式:

```
HTTP/1.1 200 OK\r\n
Content-type: text/html;charset=utf-8\r\n
Content-length: 11\r\n
\r\n
hello world
```

其实请求的格式也是类似的，只需要修改一下请求行：

```
GET /get HTTP/1.1\r\n
Host: httpbin.org:8000\r\n
\r\n
```

正确的 http 发送方式是这样的：

```
req_content = b'GET /get HTTP/1.1\r\nHost: httpbin.org:8000\r\n\r\n'
s.sendall(req_content)
```

现在只需要把上面的代码封装一下。 首先创建一个连接类

```
class Connection:
    def __init__(self):
        self.socket = socket.socket()

    def connect(self, host, port):
        self.socket.connect((host, port))

    def send(self, method, url, headers=None, data=None, version=None):
        request = Request(method, url, headers, data, version)
        self.connect(request.host, request.port)
        self.socket.sendall(request.content)
        resp = Response(self.socket)
        self.socket.close()
        return resp

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        return self.close()

    def close(self):
        self.socket.close()
```

重点是 send 方法，通过 Request 对象，组装 http 请求格式，最终发出去的数据符合 http 规范。 然后通过 socket 发送出去，接下来通过 Response 对象解析原始数据。

对应的 Request 类代码：

```
class Request:
    def __init__(
            self,
            method,
            url,
            headers=None,
            data=None,
            version=None
    ):

        self.method = method
        self.full_url = url

        result = urlparse(self.full_url)
        if not result.scheme:
            raise ValueError('invalid schema, please check url like http://...')
        self.schema = result.scheme.upper()
        self.host, _, port = result.netloc.partition(':')
        self.port = int(port) if port else 80
        self.path = result.path
        self.query = result.query

        self.headers = headers or {}
        self.data = data
        self.version = version or '1.1'

    @property
    def content(self):
        req = ' '.join([self.method.upper(),
                        self.path,
                        self.schema + '/' + self.version]) + '\r\n'
        self.headers.setdefault('host', self.host + ':' + str(self.port))
        for header_name, header_value in self.headers.items():
            req += ': '.join([header_name.capitalize(), header_value])
            req += '\r\n'
        req += '\r\n'

        # TODO: data 有 bug, 传递格式不对
        if self.data:
            req += _json.dumps(self.data)
            req += '\n'

        return req.encode()
```

Response 代码：

```
class Response:

    def __init__(self, sock):
        self.socket = sock
        self.headers = dict()
        self.status_code = None
        self.text = None

        self.parse()

    def read(self):
        content = b''
        while True:
            try:
                data = self.socket.recv(1024)
            except ConnectionResetError:
                break
            content += data
            if len(data) < 1024:
                break
        return content

    def parse(self):
        raw = self.read().decode()
        resp_line, *headers, text = raw.split('\r\n')
        _, code, _ = resp_line.split(' ', maxsplit=2)
        self.status_code = int(code)

        for header in headers[:-1]:
            name, value = header.split(': ')
            self.headers[name] = value

        self.text = text.strip()

    def json(self):
        return _json.loads(self.text)
```

现在，访问一个 http 请求的操作就比较简单了。

```
with Connection() as client:
    resp = client.send('GET', 'http://httpbin.org/get')

print(resp.status_code)
print(resp.text)
print(resp.json())
```

对于常用的请求方法，直接写成函数访问：

```
def get(url, headers=None, **kwargs):
    with Connection() as s:
        return s.send('GET', url, headers, **kwargs)

def post(url, headers=None, data=None, **kwargs):
    with Connection() as s:
        return s.send('POST', url, headers, data, **kwargs)

resp = get(url)
print(resp.text)
```



- python socket: https://docs.python.org/3.10/library/socket.html
- socket server: https://docs.python.org/3.10/library/socketserver.html#module-socketserver








## 目录

（该文章要求我们多读几个框架源码，像 webpy, bottle, flask）

- web框架的功能设计（一个微框架需要包含哪些核心功能）
    - 核心是处理请求、返回响应
    - 服务和应用分离（WSGI）
    - 方便自定义路由
    - 常见的中间件支持
- 如何编程处理网络请求（socket）
- HTTP 消息规范
- 如何接收 HTTP 请求
    - HTTP 请求规范
    - 获取 URL 和 客户端地址（如何 ban ip）
    - 获取请求方法
    - 获取请求头
    - 获取请求体
- 如何返回 HTTP 响应
    - HTTP 响应规范
    - 普通文本响应
    - 错误处理
    - HTML 文件响应（TODO:模板支持）
    - JSON 数据响应
    - 文件响应
- 服务和应用拆分
    - WSGI 协议
- 多线程支持
- 路由
- 中间件
    - 登录
    - 数据库


##  web框架的功能设计

我是一名python开发者，平时的主要是编写自动化程序，偶尔我会把一些自动化程序集成到网页当中，提供用可视化的界面，让自动化程序变得更加容易使用。在实际的工作过程当中，我接触了非常多优秀的 Web开发框架，比如非常主流的 Django 框架，它提供的功能非常的丰富；还有很多人入门学习的 Flask框架，他的设计与众不同，而且提供了非常丰富的插件系统；还有近年来非常流行的 FastAPI 框架，它提供了传统框架没有的序列化功能、依赖注入功能及后台任务功能。


这些框架的核心用法实际上大同小异，只要掌握了其中的一个框架，去学习另外的框架，会更加简单。 但是在现实生活当中总是会有很多人争论：到底哪一个框架更先进？到底那个框架容易使用？ 每次听到这样的争吵，我总是会思考一个问题：一个web开发框架究竟应该具备哪些核心的功能？而哪些功能可以通过比较方便的形式进行扩展？

当第一次接入接触web开发的时候，哪些知识应该重点去学习，而哪些可以慢慢摸索呢？在出现一些比较隐秘的问题需要解决时，应该采取什么方式去进行调试呢？这些问题都可以通过研究框架结构、深入学习源码而解决，但是随着这些现成框架的发展，他们的底层api已经隐藏的非常深，要弄清它们的原理并不容易。

这让萌生出自己开发一个玩具框架的设想，通过设计这一个玩具框架，我会明白一个Web开发框架应该具备什么样的核心功能，而这些核心功能究竟是通过一种怎样的机制完成的。 之后再采用这个设计蓝图和实现方式去理解目前主流框架的用法，应该会变得更加简单。


这个玩具框架的初步设想，是实现一个web框架应该具备的核心功能，之后再去考虑扩展功能，比如说加入数据库的支持，加入序列化和反序列化，加入后台任务的执行，加入依赖注入的功能，加入插件系统的研发。

那么一个web框架，首先应该具备一些什么样的核心功能？

在不考虑易用性的前提下，一个web框架必须具备的能力是: 接收用户发送过来的请求，经过开发者的处理之后，给用户返回开发者预先设置的响应结果。现阶段大多数web应用基于 http 协议，当 web 框架接收用户传过来的数据流之后，需先验证是否符合 http 规范。如果符合，再从中解析出请求首行、请求头以及请求体等内容。中间是应用处理环节，开发者拿到web框架解析完的请求数据之后，编写对应的处理代码，得到最终需要返回给用户的数据。最后，框架拿到开发者的返回数据，再转化成符合http规范的数据，用户便能从客户端得到响应结果。这个流程可以通过下图表示：

用户 --> 框架（验证，开发者代码，拼接 http 响应） --> 用户
（图）

那么开发者需要编写的代码有哪些呢？首先开发者需要自己定义 URL 和需要执行的代码之间的映射关系（通常定义成函数或者方法）。框架接收所有用户发过来的请求，从中得到url路径，如果该路径已经被开发者预先设置，则调用映射的代码；如果 url 没有被开发者预先配置，框架直接返回 404 状态码。其次，开发者可以更预先设置访问某个 URL 的请求方法，如果进入的该 URL 的请求方法满足预先条件，才执行映射的代码，否则 web 框架会直接抛出 405 状态码。

用户  -->  URL不匹配 --> 404
            URL 匹配  --> 开发者代码 --> response

例如，开发者预先设置进入`/login`路径的请求方法只能是 POST 请求。当一个访问该路径的请求被框架解析后，读取实际请求方法为 GET，则直接被框架定义为非法请求，返回 405 状态码，完全不会进入开发者业务。只有当实际的请求方法和开发者设置的请求方法匹配时，才会进入开发者定义的代码逻辑。

用户 -->  URL 匹配 --> 请求方法不匹配 --> 405
                       请求方法匹配  --> 开发者代码 --> Respone

只要实现了对请求方法的验证，可以基于同样的原理，由开发者预先设置其他请求数据的规则，只有符合规则，才调用开发者业务。 比如，请求头必须带有指定参数，客户端 IP 不能在黑名单，指定 IP 在规定时间内只能访问限制范围次数，甚至请求体的每个字段必须满足什么条件等等。 这些验证过程可以通过框架实现，也可以写成扩展的形式。 框架本身只要能够获取请求的url路径、请求方法、请求头、请求体、远程ip等内容，就可以用任意方式实现这些功能，FastAPI 就是在框架层面支持了反序列化以及请求校验的功能，而 Flask 对不同的请求部分验证采用了不同实现方式，有的通过路由配置，有的通过 request 读取，有的通过插件接入。


用户 --> URL适配 --> Response
        请求方法
        请求头
        IP







